// primitive data types
num = @{ int+ }
int = { ASCII_DIGIT+ }

ident_syms = _{ "_" | "." | "-" }

identifier = @{ ("_" | ASCII_ALPHA)+ ~ (ident_syms | ASCII_ALPHA | ASCII_DIGIT)* }
number = @{ ASCII_DIGIT+ }

// toplevel stmt parsing

file = {
    SOI
    ~ module
    ~ ANY*
    ~ EOI
}

module = {
    "module"
    ~ (module_kv ~ ("," ~ module_kv)*)? ~ NEWLINE
    ~ funcs
}

module_kv = {
    identifier ~ "=" ~ identifier
}

funcs = {
    func+
}

func = {
    identifier?
    ~ "func"
    ~ identifier
    ~ func_arg_list
    ~ block
}

func_arg_list = {
    "("
    ~ (identifier ~ ("," ~ identifier)*)?
    ~ ")"
}

block = {
    "{" ~ NEWLINE
    ~ (stmt ~ NEWLINE)*
    ~ "}"
}

stmt = {
    let_stmt | for_stmt | if_stmt | produce_stmt | predicate_stmt | update_stmt
  | expr
}

let_stmt = {
    "let"
    ~ identifier
    ~ "="
    ~ expr
}

for_stmt = {
    "for" ~ "(" ~ expr ~ "," ~ expr ~ "," ~ expr ~ ")"
    ~ block
}

if_stmt = {
    "if" ~ "(" ~ expr ~ ")" ~ block ~ ("else" ~ (if_stmt | block))?
}

produce_stmt = {
    "produce" ~ identifier ~ block
}

predicate_stmt = {
    "predicate" ~ expr ~ NEWLINE ~ stmt
}

update_stmt = {
    identifier ~ "[" ~ expr ~ "]" ~ "=" ~ expr
}

// binary operations
expr = {
    primary ~ (infix ~ primary)*
}

infix = _{
    add | sub | mul | div | modulo
  | lte | lt | eq | neq | gte | gt | if_infx
}
add     = { "+" }
sub     = { "-" }
mul     = { "*" }
div     = { "/" }
modulo  = { "%" }
lt      = { "<" }
lte     = { "<=" }
eq      = { "==" }
neq     = { "!=" }
gte     = { ">=" }
gt      = { ">" }
if_infx = { "if" }
primary = _{
    funcall
  | cast_expr
  | access_expr
  | number
  | identifier
  | "(" ~ expr ~ ")"
}

// function calls
funcall = {
    identifier
    ~ "(" ~ funcall_args? ~ ")"
}

funcall_args = {
    expr ~ ("," ~ expr)*
}

// cast expressions
cast_expr = {
    "(" ~ cast_args? ~ ")" ~ expr
}

ptr = { "*" }
cast_args = {
    identifier ~ (identifier | ptr)*
}

// array access
access_expr = {
    identifier ~ "[" ~ expr ~ "]"
}

WHITESPACE = _{ " " | "\t" }
COMMENT = _{ ("//" ~ (!NEWLINE ~ ANY)* ~ NEWLINE) | "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
